<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="List names here">
<meta name="dcterms.date" content="2025-11-05">

<title>Biomarkers of ASD</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="report_files/libs/clipboard/clipboard.min.js"></script>
<script src="report_files/libs/quarto-html/quarto.js"></script>
<script src="report_files/libs/quarto-html/popper.min.js"></script>
<script src="report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="report_files/libs/quarto-html/anchor.min.js"></script>
<link href="report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="report_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="report_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Biomarkers of ASD</h1>
<p class="subtitle lead">If you want a subtitle put it here</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>List names here </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Updated</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 5, 2025</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>We examined a publicly accessible serum proteomics dataset for this assignment (Hewitson et al., 2021). This allowed us to investigate biomarkers for autism spectrum disorder (ASD) early detection. We repeated the in-class pipeline univalent t-tests, random forest significance, and logistic regression classification using the provided class-cleaned dataset. Next, we investigated how sensitive the results were to various design decisions. In order to enable subsequent parametric testing, we first verified that log transformation improves the symmetry and variance stability of protein distributions. Second, there was a small number of subjects with numerous outliers but no significant imbalance between the ASD and TD groups after outlier trimming was removed and |z|&gt;3 values were counted by subject. Third, using simply a training partition, we examined three different selection strategies: (i) baseline hard intersection, (ii) increasing the number of top proteins, and (iii) a “fuzzy” intersection based on averaged ranks. Lastly, we looked for panels that performed better or were smaller. Classification was resilient across settings; a 20-protein panel produced the greatest accuracy (~0.78) with strong sensitivity, whereas a 12-protein panel achieved a balanced trade-off (ROC AUC = 0.80). These findings imply that a small protein panel can perform on par with bigger sets, with rankings from several selectors offering a consistent, understandable route to potential biomarkers.</p>
</section>
<section id="dataset" class="level2">
<h2 class="anchored" data-anchor-id="dataset">Dataset</h2>
<p>Hewitson et al.&nbsp;(2021), “Blood biomarker discovery for autism spectrum disorder: A proteomic analysis” (PLoS One), provided the dataset used in this analysis. Relative protein abundances in serum samples from children with autism spectrum disorder (ASD) and normally developing (TD) controls were assessed in the initial investigation. Antibody-based multiplex immunoassays that targeted more than 1,000 blood proteins associated with immunological, inflammatory, and developmental pathways were used to measure protein levels. Both the raw biomarker readings (biomarker-raw.csv) and a cleaned, preprocessed version (biomarker-clean.RData) used for modeling are included in the dataset supplied for this assignment. A measured protein is represented by each column, and a diagnostic group (ASD or TD) and an ADOS score used in behavioral assessment are indicated by an additional variable. Each row represents a single participant.</p>
<p>The methods described in class were followed during data preprocessing. In order to stabilize variation among markers and lessen right skewness, protein concentrations were log-transformed, producing roughly symmetric distributions that were appropriate for statistical modeling. To reduce distortion from extreme data, outlier values (|z| &gt; 3) were found and clipped. Variables with insufficient variance were eliminated, and missing or undetectable protein levels were imputed or eliminated as needed. Normalized and filtered protein measurements are included in the final cleaned dataset, which is prepared for both univariate and multivariate feature-selection studies.</p>
</section>
<section id="summary-of-published-analysis" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-published-analysis">Summary of published analysis</h2>
<p>Finding blood proteins that can distinguish between children with autism spectrum disorder (ASD) and normally developing (TD) controls was the goal of the published analysis by Hewitson et al.&nbsp;(2021). The dataset included behavioral and diagnostic data in addition to quantitative measurements for more than a thousand serum proteins. We used a combination of univariate and machine learning techniques to find predictive biomarkers and assess their classification accuracy in order to replicate and expand this analysis.</p>
<p>For each protein, we first compared the ASD and TD groups using two-sample t-tests to determine which had statistically significant mean differences. In addition, a random forest classifier was trained to provide a nonparametric measure of variable relevance by ranking proteins according to Mean Decrease in Gini. A parsimonious feature set for classification was then created using the intersection of the top proteins from the two selection techniques. This fraction was used to construct a logistic regression model, and sensitivity, specificity, accuracy, and ROC AUC metrics were used to evaluate the model’s performance on a held-out test partition.</p>
<p>Based on the intersecting proteins DERM, RELT, MRC2, IgD, and Cadherin-5, our final classifier has an accuracy of 0.774, sensitivity of 0.812, specificity of 0.733, and ROC AUC of 0.883. These findings imply that a limited panel of immunological and adhesion-related proteins can successfully differentiate ASD from TD samples. They also show high discriminatory performance and are consistent with trends reported in the source study.</p>
</section>
<section id="findings" class="level2">
<h2 class="anchored" data-anchor-id="findings">Findings</h2>
<p>Summarize your findings here. I’ve included some subheaders in a way that seems natural to me; you can structure this section however you like.</p>
<section id="impact-of-preprocessing-and-outliers" class="level3">
<h3 class="anchored" data-anchor-id="impact-of-preprocessing-and-outliers">Impact of preprocessing and outliers</h3>
<p>The distributional symmetry of measured values was significantly enhanced by log-transforming protein levels in the raw dataset, which also reduced extreme right-skewness and made the data more normally distributed. This modification increases the reliability of subsequent parametric analyses (like t-tests) and helps stabilize variance across proteins.<br>
<br>
Exploratory research showed that a small number of participants had disproportionately high or low protein amounts across numerous biomarkers when outlier trimming was temporarily eliminated. The ASD cohort had a somewhat higher number of these outliers than the other groups. It appears that outlier handling had a significant impact on model stability and reproducibility since their removal stopped these extreme profiles from unreasonably affecting the mean and variance estimations.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/log_transform.png" class="img-fluid figure-img"></p>
</figure>
</div>
<p>The log transformation makes protein distributions more symmetric and reduces skewness.</p>
</section>
<section id="methodological-variations" class="level3">
<h3 class="anchored" data-anchor-id="methodological-variations">Methodological variations</h3>
<p>Model performance fluctuated little but stayed within a constant accuracy range when methodological factors were changed.<br>
Overfitting was decreased and a more accurate assessment of prediction accuracy was obtained by training on a dedicated partition before to testing.<br>
The ROC AUC increased somewhat (up to ≈ 0.88) when the number of top predictive proteins was increased beyond 10 (e.g., to 15 or 20), but neither sensitivity nor specificity significantly improved.<br>
A few more candidate proteins were added by using a fuzzy intersection rather than a rigid overlap across selection methods, which slightly increased coverage but had no effect on speed.<br>
All things considered, these tests showed that the predictive behavior of the model was comparatively resilient to minor methodological changes.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/panel_auc_vs_size.png" class="img-fluid figure-img"></p>
</figure>
</div>
<p>A larger number of selected proteins improves ROC AUC marginally but yields diminishing returns after about 12–15 features.</p>
</section>
<section id="improved-classifier" class="level3">
<h3 class="anchored" data-anchor-id="improved-classifier">Improved classifier</h3>
<p>The final logistic regression classifier produced robust and balanced performance using the improved intersection of features, including DERM, RELT, MRC2, IgD, and Cadherin-5:<br>
</p>
<ul>
<li><p>0.812 is the sensitivity.</p></li>
<li><p>Specificity: 0.733</p></li>
<li><p>0.774 is the accuracy.</p></li>
<li><p>ROC AUC is 0.883.<br>
</p>
<p>The accuracy of this simplified five-protein panel was on par with or higher than that of the more intricate models described in the source publication and in class. The biological validity of these proteins as potential early indicators is supported by the high AUC, which shows that the classifier consistently differentiates between ASD and TD patients.</p></li>
</ul>
<p><img src="plots/rf_top10_training_partition.png" class="img-fluid" data-fig-align="center"> <img src="plots/rf_top20_training_partition.png" class="img-fluid" data-fig-align="center"></p>
<p>The model trained on the top 20 features shows a slightly higher AUC than the top 10 model.</p>
<section id="fuzzy-intersection-of-selected-proteins" class="level4">
<h4 class="anchored" data-anchor-id="fuzzy-intersection-of-selected-proteins">Fuzzy intersection of selected proteins</h4>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/fuzzy_intersection_proteins.png" class="img-fluid figure-img"></p>
</figure>
</div>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>